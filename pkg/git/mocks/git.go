// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	git "github.com/instruqt/git-exec/pkg/git"
	mock "github.com/stretchr/testify/mock"

	types "github.com/instruqt/git-exec/pkg/git/types"
)

// MockGit is an autogenerated mock type for the Git type
type MockGit struct {
	mock.Mock
}

type MockGit_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGit) EXPECT() *MockGit_Expecter {
	return &MockGit_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: files, options
func (_m *MockGit) Add(files []string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, ...git.Option) error); ok {
		r0 = rf(files, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockGit_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - files []string
//   - options ...git.Option
func (_e *MockGit_Expecter) Add(files interface{}, options ...interface{}) *MockGit_Add_Call {
	return &MockGit_Add_Call{Call: _e.mock.On("Add",
		append([]interface{}{files}, options...)...)}
}

func (_c *MockGit_Add_Call) Run(run func(files []string, options ...git.Option)) *MockGit_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Add_Call) Return(_a0 error) *MockGit_Add_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Add_Call) RunAndReturn(run func([]string, ...git.Option) error) *MockGit_Add_Call {
	_c.Call.Return(run)
	return _c
}

// AddRemote provides a mock function with given fields: name, url, options
func (_m *MockGit) AddRemote(name string, url string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddRemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(name, url, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_AddRemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRemote'
type MockGit_AddRemote_Call struct {
	*mock.Call
}

// AddRemote is a helper method to define mock.On call
//   - name string
//   - url string
//   - options ...git.Option
func (_e *MockGit_Expecter) AddRemote(name interface{}, url interface{}, options ...interface{}) *MockGit_AddRemote_Call {
	return &MockGit_AddRemote_Call{Call: _e.mock.On("AddRemote",
		append([]interface{}{name, url}, options...)...)}
}

func (_c *MockGit_AddRemote_Call) Run(run func(name string, url string, options ...git.Option)) *MockGit_AddRemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_AddRemote_Call) Return(_a0 error) *MockGit_AddRemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_AddRemote_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_AddRemote_Call {
	_c.Call.Return(run)
	return _c
}

// Checkout provides a mock function with given fields: options
func (_m *MockGit) Checkout(options ...git.Option) (*types.CheckoutResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Checkout")
	}

	var r0 *types.CheckoutResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.CheckoutResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.CheckoutResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CheckoutResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Checkout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checkout'
type MockGit_Checkout_Call struct {
	*mock.Call
}

// Checkout is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Checkout(options ...interface{}) *MockGit_Checkout_Call {
	return &MockGit_Checkout_Call{Call: _e.mock.On("Checkout",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Checkout_Call) Run(run func(options ...git.Option)) *MockGit_Checkout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Checkout_Call) Return(_a0 *types.CheckoutResult, _a1 error) *MockGit_Checkout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Checkout_Call) RunAndReturn(run func(...git.Option) (*types.CheckoutResult, error)) *MockGit_Checkout_Call {
	_c.Call.Return(run)
	return _c
}

// Clone provides a mock function with given fields: url, destination, options
func (_m *MockGit) Clone(url string, destination string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, url, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Clone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(url, destination, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Clone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clone'
type MockGit_Clone_Call struct {
	*mock.Call
}

// Clone is a helper method to define mock.On call
//   - url string
//   - destination string
//   - options ...git.Option
func (_e *MockGit_Expecter) Clone(url interface{}, destination interface{}, options ...interface{}) *MockGit_Clone_Call {
	return &MockGit_Clone_Call{Call: _e.mock.On("Clone",
		append([]interface{}{url, destination}, options...)...)}
}

func (_c *MockGit_Clone_Call) Run(run func(url string, destination string, options ...git.Option)) *MockGit_Clone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Clone_Call) Return(_a0 error) *MockGit_Clone_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Clone_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_Clone_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: message, options
func (_m *MockGit) Commit(message string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, message)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(message, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockGit_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - message string
//   - options ...git.Option
func (_e *MockGit_Expecter) Commit(message interface{}, options ...interface{}) *MockGit_Commit_Call {
	return &MockGit_Commit_Call{Call: _e.mock.On("Commit",
		append([]interface{}{message}, options...)...)}
}

func (_c *MockGit_Commit_Call) Run(run func(message string, options ...git.Option)) *MockGit_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Commit_Call) Return(_a0 error) *MockGit_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Commit_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranch provides a mock function with given fields: branch, options
func (_m *MockGit) CreateBranch(branch string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(branch, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CreateBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranch'
type MockGit_CreateBranch_Call struct {
	*mock.Call
}

// CreateBranch is a helper method to define mock.On call
//   - branch string
//   - options ...git.Option
func (_e *MockGit_Expecter) CreateBranch(branch interface{}, options ...interface{}) *MockGit_CreateBranch_Call {
	return &MockGit_CreateBranch_Call{Call: _e.mock.On("CreateBranch",
		append([]interface{}{branch}, options...)...)}
}

func (_c *MockGit_CreateBranch_Call) Run(run func(branch string, options ...git.Option)) *MockGit_CreateBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_CreateBranch_Call) Return(_a0 error) *MockGit_CreateBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CreateBranch_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_CreateBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBranch provides a mock function with given fields: branch, options
func (_m *MockGit) DeleteBranch(branch string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(branch, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_DeleteBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBranch'
type MockGit_DeleteBranch_Call struct {
	*mock.Call
}

// DeleteBranch is a helper method to define mock.On call
//   - branch string
//   - options ...git.Option
func (_e *MockGit_Expecter) DeleteBranch(branch interface{}, options ...interface{}) *MockGit_DeleteBranch_Call {
	return &MockGit_DeleteBranch_Call{Call: _e.mock.On("DeleteBranch",
		append([]interface{}{branch}, options...)...)}
}

func (_c *MockGit_DeleteBranch_Call) Run(run func(branch string, options ...git.Option)) *MockGit_DeleteBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_DeleteBranch_Call) Return(_a0 error) *MockGit_DeleteBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_DeleteBranch_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_DeleteBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRemoteTag provides a mock function with given fields: remote, tagName, options
func (_m *MockGit) DeleteRemoteTag(remote string, tagName string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, remote, tagName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRemoteTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(remote, tagName, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_DeleteRemoteTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRemoteTag'
type MockGit_DeleteRemoteTag_Call struct {
	*mock.Call
}

// DeleteRemoteTag is a helper method to define mock.On call
//   - remote string
//   - tagName string
//   - options ...git.Option
func (_e *MockGit_Expecter) DeleteRemoteTag(remote interface{}, tagName interface{}, options ...interface{}) *MockGit_DeleteRemoteTag_Call {
	return &MockGit_DeleteRemoteTag_Call{Call: _e.mock.On("DeleteRemoteTag",
		append([]interface{}{remote, tagName}, options...)...)}
}

func (_c *MockGit_DeleteRemoteTag_Call) Run(run func(remote string, tagName string, options ...git.Option)) *MockGit_DeleteRemoteTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_DeleteRemoteTag_Call) Return(_a0 error) *MockGit_DeleteRemoteTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_DeleteRemoteTag_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_DeleteRemoteTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTag provides a mock function with given fields: name, options
func (_m *MockGit) DeleteTag(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_DeleteTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTag'
type MockGit_DeleteTag_Call struct {
	*mock.Call
}

// DeleteTag is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockGit_Expecter) DeleteTag(name interface{}, options ...interface{}) *MockGit_DeleteTag_Call {
	return &MockGit_DeleteTag_Call{Call: _e.mock.On("DeleteTag",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockGit_DeleteTag_Call) Run(run func(name string, options ...git.Option)) *MockGit_DeleteTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_DeleteTag_Call) Return(_a0 error) *MockGit_DeleteTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_DeleteTag_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_DeleteTag_Call {
	_c.Call.Return(run)
	return _c
}

// Diff provides a mock function with given fields: options
func (_m *MockGit) Diff(options ...git.Option) ([]types.Diff, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Diff")
	}

	var r0 []types.Diff
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Diff, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Diff); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Diff)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Diff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Diff'
type MockGit_Diff_Call struct {
	*mock.Call
}

// Diff is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Diff(options ...interface{}) *MockGit_Diff_Call {
	return &MockGit_Diff_Call{Call: _e.mock.On("Diff",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Diff_Call) Run(run func(options ...git.Option)) *MockGit_Diff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Diff_Call) Return(_a0 []types.Diff, _a1 error) *MockGit_Diff_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Diff_Call) RunAndReturn(run func(...git.Option) ([]types.Diff, error)) *MockGit_Diff_Call {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function with given fields: options
func (_m *MockGit) Fetch(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type MockGit_Fetch_Call struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Fetch(options ...interface{}) *MockGit_Fetch_Call {
	return &MockGit_Fetch_Call{Call: _e.mock.On("Fetch",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Fetch_Call) Run(run func(options ...git.Option)) *MockGit_Fetch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Fetch_Call) Return(_a0 []types.Remote, _a1 error) *MockGit_Fetch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Fetch_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockGit_Fetch_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: key, options
func (_m *MockGit) GetConfig(key string, options ...git.Option) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) (string, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) string); ok {
		r0 = rf(key, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type MockGit_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - key string
//   - options ...git.Option
func (_e *MockGit_Expecter) GetConfig(key interface{}, options ...interface{}) *MockGit_GetConfig_Call {
	return &MockGit_GetConfig_Call{Call: _e.mock.On("GetConfig",
		append([]interface{}{key}, options...)...)}
}

func (_c *MockGit_GetConfig_Call) Run(run func(key string, options ...git.Option)) *MockGit_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_GetConfig_Call) Return(_a0 string, _a1 error) *MockGit_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_GetConfig_Call) RunAndReturn(run func(string, ...git.Option) (string, error)) *MockGit_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function with given fields: path, options
func (_m *MockGit) Init(path string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, path)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(path, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type MockGit_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - path string
//   - options ...git.Option
func (_e *MockGit_Expecter) Init(path interface{}, options ...interface{}) *MockGit_Init_Call {
	return &MockGit_Init_Call{Call: _e.mock.On("Init",
		append([]interface{}{path}, options...)...)}
}

func (_c *MockGit_Init_Call) Run(run func(path string, options ...git.Option)) *MockGit_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Init_Call) Return(_a0 error) *MockGit_Init_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Init_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_Init_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranches provides a mock function with given fields: options
func (_m *MockGit) ListBranches(options ...git.Option) ([]types.Branch, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBranches")
	}

	var r0 []types.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Branch, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Branch); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_ListBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranches'
type MockGit_ListBranches_Call struct {
	*mock.Call
}

// ListBranches is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) ListBranches(options ...interface{}) *MockGit_ListBranches_Call {
	return &MockGit_ListBranches_Call{Call: _e.mock.On("ListBranches",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_ListBranches_Call) Run(run func(options ...git.Option)) *MockGit_ListBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_ListBranches_Call) Return(_a0 []types.Branch, _a1 error) *MockGit_ListBranches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_ListBranches_Call) RunAndReturn(run func(...git.Option) ([]types.Branch, error)) *MockGit_ListBranches_Call {
	_c.Call.Return(run)
	return _c
}

// ListConfig provides a mock function with given fields: options
func (_m *MockGit) ListConfig(options ...git.Option) ([]types.ConfigEntry, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfig")
	}

	var r0 []types.ConfigEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.ConfigEntry, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.ConfigEntry); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ConfigEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_ListConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListConfig'
type MockGit_ListConfig_Call struct {
	*mock.Call
}

// ListConfig is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) ListConfig(options ...interface{}) *MockGit_ListConfig_Call {
	return &MockGit_ListConfig_Call{Call: _e.mock.On("ListConfig",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_ListConfig_Call) Run(run func(options ...git.Option)) *MockGit_ListConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_ListConfig_Call) Return(_a0 []types.ConfigEntry, _a1 error) *MockGit_ListConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_ListConfig_Call) RunAndReturn(run func(...git.Option) ([]types.ConfigEntry, error)) *MockGit_ListConfig_Call {
	_c.Call.Return(run)
	return _c
}

// ListRemotes provides a mock function with given fields: options
func (_m *MockGit) ListRemotes(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRemotes")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_ListRemotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRemotes'
type MockGit_ListRemotes_Call struct {
	*mock.Call
}

// ListRemotes is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) ListRemotes(options ...interface{}) *MockGit_ListRemotes_Call {
	return &MockGit_ListRemotes_Call{Call: _e.mock.On("ListRemotes",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_ListRemotes_Call) Run(run func(options ...git.Option)) *MockGit_ListRemotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_ListRemotes_Call) Return(_a0 []types.Remote, _a1 error) *MockGit_ListRemotes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_ListRemotes_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockGit_ListRemotes_Call {
	_c.Call.Return(run)
	return _c
}

// ListTags provides a mock function with given fields: options
func (_m *MockGit) ListTags(options ...git.Option) ([]string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]string, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []string); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_ListTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTags'
type MockGit_ListTags_Call struct {
	*mock.Call
}

// ListTags is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) ListTags(options ...interface{}) *MockGit_ListTags_Call {
	return &MockGit_ListTags_Call{Call: _e.mock.On("ListTags",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_ListTags_Call) Run(run func(options ...git.Option)) *MockGit_ListTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_ListTags_Call) Return(_a0 []string, _a1 error) *MockGit_ListTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_ListTags_Call) RunAndReturn(run func(...git.Option) ([]string, error)) *MockGit_ListTags_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function with given fields: options
func (_m *MockGit) Log(options ...git.Option) ([]types.Log, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Log")
	}

	var r0 []types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Log, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Log); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type MockGit_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Log(options ...interface{}) *MockGit_Log_Call {
	return &MockGit_Log_Call{Call: _e.mock.On("Log",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Log_Call) Run(run func(options ...git.Option)) *MockGit_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Log_Call) Return(_a0 []types.Log, _a1 error) *MockGit_Log_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Log_Call) RunAndReturn(run func(...git.Option) ([]types.Log, error)) *MockGit_Log_Call {
	_c.Call.Return(run)
	return _c
}

// Merge provides a mock function with given fields: options
func (_m *MockGit) Merge(options ...git.Option) (*types.MergeResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Merge")
	}

	var r0 *types.MergeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.MergeResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.MergeResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MergeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Merge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Merge'
type MockGit_Merge_Call struct {
	*mock.Call
}

// Merge is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Merge(options ...interface{}) *MockGit_Merge_Call {
	return &MockGit_Merge_Call{Call: _e.mock.On("Merge",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Merge_Call) Run(run func(options ...git.Option)) *MockGit_Merge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Merge_Call) Return(_a0 *types.MergeResult, _a1 error) *MockGit_Merge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Merge_Call) RunAndReturn(run func(...git.Option) (*types.MergeResult, error)) *MockGit_Merge_Call {
	_c.Call.Return(run)
	return _c
}

// MergeAbort provides a mock function with no fields
func (_m *MockGit) MergeAbort() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MergeAbort")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_MergeAbort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeAbort'
type MockGit_MergeAbort_Call struct {
	*mock.Call
}

// MergeAbort is a helper method to define mock.On call
func (_e *MockGit_Expecter) MergeAbort() *MockGit_MergeAbort_Call {
	return &MockGit_MergeAbort_Call{Call: _e.mock.On("MergeAbort")}
}

func (_c *MockGit_MergeAbort_Call) Run(run func()) *MockGit_MergeAbort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGit_MergeAbort_Call) Return(_a0 error) *MockGit_MergeAbort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_MergeAbort_Call) RunAndReturn(run func() error) *MockGit_MergeAbort_Call {
	_c.Call.Return(run)
	return _c
}

// MergeContinue provides a mock function with no fields
func (_m *MockGit) MergeContinue() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MergeContinue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_MergeContinue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeContinue'
type MockGit_MergeContinue_Call struct {
	*mock.Call
}

// MergeContinue is a helper method to define mock.On call
func (_e *MockGit_Expecter) MergeContinue() *MockGit_MergeContinue_Call {
	return &MockGit_MergeContinue_Call{Call: _e.mock.On("MergeContinue")}
}

func (_c *MockGit_MergeContinue_Call) Run(run func()) *MockGit_MergeContinue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGit_MergeContinue_Call) Return(_a0 error) *MockGit_MergeContinue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_MergeContinue_Call) RunAndReturn(run func() error) *MockGit_MergeContinue_Call {
	_c.Call.Return(run)
	return _c
}

// Pull provides a mock function with given fields: options
func (_m *MockGit) Pull(options ...git.Option) (*types.MergeResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Pull")
	}

	var r0 *types.MergeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.MergeResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.MergeResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MergeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Pull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pull'
type MockGit_Pull_Call struct {
	*mock.Call
}

// Pull is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Pull(options ...interface{}) *MockGit_Pull_Call {
	return &MockGit_Pull_Call{Call: _e.mock.On("Pull",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Pull_Call) Run(run func(options ...git.Option)) *MockGit_Pull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Pull_Call) Return(_a0 *types.MergeResult, _a1 error) *MockGit_Pull_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Pull_Call) RunAndReturn(run func(...git.Option) (*types.MergeResult, error)) *MockGit_Pull_Call {
	_c.Call.Return(run)
	return _c
}

// Push provides a mock function with given fields: options
func (_m *MockGit) Push(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Push")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Push_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Push'
type MockGit_Push_Call struct {
	*mock.Call
}

// Push is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Push(options ...interface{}) *MockGit_Push_Call {
	return &MockGit_Push_Call{Call: _e.mock.On("Push",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Push_Call) Run(run func(options ...git.Option)) *MockGit_Push_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Push_Call) Return(_a0 []types.Remote, _a1 error) *MockGit_Push_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Push_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockGit_Push_Call {
	_c.Call.Return(run)
	return _c
}

// PushTags provides a mock function with given fields: remote, options
func (_m *MockGit) PushTags(remote string, options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, remote)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PushTags")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) ([]types.Remote, error)); ok {
		return rf(remote, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) []types.Remote); ok {
		r0 = rf(remote, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(remote, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_PushTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PushTags'
type MockGit_PushTags_Call struct {
	*mock.Call
}

// PushTags is a helper method to define mock.On call
//   - remote string
//   - options ...git.Option
func (_e *MockGit_Expecter) PushTags(remote interface{}, options ...interface{}) *MockGit_PushTags_Call {
	return &MockGit_PushTags_Call{Call: _e.mock.On("PushTags",
		append([]interface{}{remote}, options...)...)}
}

func (_c *MockGit_PushTags_Call) Run(run func(remote string, options ...git.Option)) *MockGit_PushTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_PushTags_Call) Return(_a0 []types.Remote, _a1 error) *MockGit_PushTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_PushTags_Call) RunAndReturn(run func(string, ...git.Option) ([]types.Remote, error)) *MockGit_PushTags_Call {
	_c.Call.Return(run)
	return _c
}

// Rebase provides a mock function with given fields: options
func (_m *MockGit) Rebase(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Rebase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Rebase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rebase'
type MockGit_Rebase_Call struct {
	*mock.Call
}

// Rebase is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Rebase(options ...interface{}) *MockGit_Rebase_Call {
	return &MockGit_Rebase_Call{Call: _e.mock.On("Rebase",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Rebase_Call) Run(run func(options ...git.Option)) *MockGit_Rebase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Rebase_Call) Return(_a0 error) *MockGit_Rebase_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Rebase_Call) RunAndReturn(run func(...git.Option) error) *MockGit_Rebase_Call {
	_c.Call.Return(run)
	return _c
}

// Reflog provides a mock function with given fields: options
func (_m *MockGit) Reflog(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Reflog")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Reflog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reflog'
type MockGit_Reflog_Call struct {
	*mock.Call
}

// Reflog is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Reflog(options ...interface{}) *MockGit_Reflog_Call {
	return &MockGit_Reflog_Call{Call: _e.mock.On("Reflog",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Reflog_Call) Run(run func(options ...git.Option)) *MockGit_Reflog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Reflog_Call) Return(_a0 error) *MockGit_Reflog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Reflog_Call) RunAndReturn(run func(...git.Option) error) *MockGit_Reflog_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: options
func (_m *MockGit) Remove(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockGit_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Remove(options ...interface{}) *MockGit_Remove_Call {
	return &MockGit_Remove_Call{Call: _e.mock.On("Remove",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Remove_Call) Run(run func(options ...git.Option)) *MockGit_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Remove_Call) Return(_a0 error) *MockGit_Remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Remove_Call) RunAndReturn(run func(...git.Option) error) *MockGit_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRemote provides a mock function with given fields: name, options
func (_m *MockGit) RemoveRemote(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_RemoveRemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRemote'
type MockGit_RemoveRemote_Call struct {
	*mock.Call
}

// RemoveRemote is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockGit_Expecter) RemoveRemote(name interface{}, options ...interface{}) *MockGit_RemoveRemote_Call {
	return &MockGit_RemoveRemote_Call{Call: _e.mock.On("RemoveRemote",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockGit_RemoveRemote_Call) Run(run func(name string, options ...git.Option)) *MockGit_RemoveRemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_RemoveRemote_Call) Return(_a0 error) *MockGit_RemoveRemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_RemoveRemote_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_RemoveRemote_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: files, options
func (_m *MockGit) Reset(files []string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, ...git.Option) error); ok {
		r0 = rf(files, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type MockGit_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - files []string
//   - options ...git.Option
func (_e *MockGit_Expecter) Reset(files interface{}, options ...interface{}) *MockGit_Reset_Call {
	return &MockGit_Reset_Call{Call: _e.mock.On("Reset",
		append([]interface{}{files}, options...)...)}
}

func (_c *MockGit_Reset_Call) Run(run func(files []string, options ...git.Option)) *MockGit_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Reset_Call) Return(_a0 error) *MockGit_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Reset_Call) RunAndReturn(run func([]string, ...git.Option) error) *MockGit_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// ResolveConflicts provides a mock function with given fields: resolutions
func (_m *MockGit) ResolveConflicts(resolutions []types.ConflictResolution) error {
	ret := _m.Called(resolutions)

	if len(ret) == 0 {
		panic("no return value specified for ResolveConflicts")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]types.ConflictResolution) error); ok {
		r0 = rf(resolutions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_ResolveConflicts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveConflicts'
type MockGit_ResolveConflicts_Call struct {
	*mock.Call
}

// ResolveConflicts is a helper method to define mock.On call
//   - resolutions []types.ConflictResolution
func (_e *MockGit_Expecter) ResolveConflicts(resolutions interface{}) *MockGit_ResolveConflicts_Call {
	return &MockGit_ResolveConflicts_Call{Call: _e.mock.On("ResolveConflicts", resolutions)}
}

func (_c *MockGit_ResolveConflicts_Call) Run(run func(resolutions []types.ConflictResolution)) *MockGit_ResolveConflicts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]types.ConflictResolution))
	})
	return _c
}

func (_c *MockGit_ResolveConflicts_Call) Return(_a0 error) *MockGit_ResolveConflicts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_ResolveConflicts_Call) RunAndReturn(run func([]types.ConflictResolution) error) *MockGit_ResolveConflicts_Call {
	_c.Call.Return(run)
	return _c
}

// Revert provides a mock function with given fields: options
func (_m *MockGit) Revert(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Revert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Revert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Revert'
type MockGit_Revert_Call struct {
	*mock.Call
}

// Revert is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Revert(options ...interface{}) *MockGit_Revert_Call {
	return &MockGit_Revert_Call{Call: _e.mock.On("Revert",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Revert_Call) Run(run func(options ...git.Option)) *MockGit_Revert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Revert_Call) Return(_a0 error) *MockGit_Revert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Revert_Call) RunAndReturn(run func(...git.Option) error) *MockGit_Revert_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: key, value, options
func (_m *MockGit) SetConfig(key string, value string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(key, value, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type MockGit_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - key string
//   - value string
//   - options ...git.Option
func (_e *MockGit_Expecter) SetConfig(key interface{}, value interface{}, options ...interface{}) *MockGit_SetConfig_Call {
	return &MockGit_SetConfig_Call{Call: _e.mock.On("SetConfig",
		append([]interface{}{key, value}, options...)...)}
}

func (_c *MockGit_SetConfig_Call) Run(run func(key string, value string, options ...git.Option)) *MockGit_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_SetConfig_Call) Return(_a0 error) *MockGit_SetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_SetConfig_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetRemoteURL provides a mock function with given fields: name, url, options
func (_m *MockGit) SetRemoteURL(name string, url string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRemoteURL")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(name, url, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_SetRemoteURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRemoteURL'
type MockGit_SetRemoteURL_Call struct {
	*mock.Call
}

// SetRemoteURL is a helper method to define mock.On call
//   - name string
//   - url string
//   - options ...git.Option
func (_e *MockGit_Expecter) SetRemoteURL(name interface{}, url interface{}, options ...interface{}) *MockGit_SetRemoteURL_Call {
	return &MockGit_SetRemoteURL_Call{Call: _e.mock.On("SetRemoteURL",
		append([]interface{}{name, url}, options...)...)}
}

func (_c *MockGit_SetRemoteURL_Call) Run(run func(name string, url string, options ...git.Option)) *MockGit_SetRemoteURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_SetRemoteURL_Call) Return(_a0 error) *MockGit_SetRemoteURL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_SetRemoteURL_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_SetRemoteURL_Call {
	_c.Call.Return(run)
	return _c
}

// SetUpstream provides a mock function with given fields: branch, remote, options
func (_m *MockGit) SetUpstream(branch string, remote string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch, remote)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetUpstream")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(branch, remote, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_SetUpstream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUpstream'
type MockGit_SetUpstream_Call struct {
	*mock.Call
}

// SetUpstream is a helper method to define mock.On call
//   - branch string
//   - remote string
//   - options ...git.Option
func (_e *MockGit_Expecter) SetUpstream(branch interface{}, remote interface{}, options ...interface{}) *MockGit_SetUpstream_Call {
	return &MockGit_SetUpstream_Call{Call: _e.mock.On("SetUpstream",
		append([]interface{}{branch, remote}, options...)...)}
}

func (_c *MockGit_SetUpstream_Call) Run(run func(branch string, remote string, options ...git.Option)) *MockGit_SetUpstream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_SetUpstream_Call) Return(_a0 error) *MockGit_SetUpstream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_SetUpstream_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockGit_SetUpstream_Call {
	_c.Call.Return(run)
	return _c
}

// SetWorkingDirectory provides a mock function with given fields: wd
func (_m *MockGit) SetWorkingDirectory(wd string) {
	_m.Called(wd)
}

// MockGit_SetWorkingDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWorkingDirectory'
type MockGit_SetWorkingDirectory_Call struct {
	*mock.Call
}

// SetWorkingDirectory is a helper method to define mock.On call
//   - wd string
func (_e *MockGit_Expecter) SetWorkingDirectory(wd interface{}) *MockGit_SetWorkingDirectory_Call {
	return &MockGit_SetWorkingDirectory_Call{Call: _e.mock.On("SetWorkingDirectory", wd)}
}

func (_c *MockGit_SetWorkingDirectory_Call) Run(run func(wd string)) *MockGit_SetWorkingDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGit_SetWorkingDirectory_Call) Return() *MockGit_SetWorkingDirectory_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockGit_SetWorkingDirectory_Call) RunAndReturn(run func(string)) *MockGit_SetWorkingDirectory_Call {
	_c.Run(run)
	return _c
}

// Show provides a mock function with given fields: object, options
func (_m *MockGit) Show(object string, options ...git.Option) (*types.Log, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, object)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Show")
	}

	var r0 *types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) (*types.Log, error)); ok {
		return rf(object, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) *types.Log); ok {
		r0 = rf(object, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(object, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Show_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Show'
type MockGit_Show_Call struct {
	*mock.Call
}

// Show is a helper method to define mock.On call
//   - object string
//   - options ...git.Option
func (_e *MockGit_Expecter) Show(object interface{}, options ...interface{}) *MockGit_Show_Call {
	return &MockGit_Show_Call{Call: _e.mock.On("Show",
		append([]interface{}{object}, options...)...)}
}

func (_c *MockGit_Show_Call) Run(run func(object string, options ...git.Option)) *MockGit_Show_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Show_Call) Return(_a0 *types.Log, _a1 error) *MockGit_Show_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Show_Call) RunAndReturn(run func(string, ...git.Option) (*types.Log, error)) *MockGit_Show_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: options
func (_m *MockGit) Status(options ...git.Option) ([]types.File, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 []types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.File, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.File); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockGit_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockGit_Expecter) Status(options ...interface{}) *MockGit_Status_Call {
	return &MockGit_Status_Call{Call: _e.mock.On("Status",
		append([]interface{}{}, options...)...)}
}

func (_c *MockGit_Status_Call) Run(run func(options ...git.Option)) *MockGit_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Status_Call) Return(_a0 []types.File, _a1 error) *MockGit_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_Status_Call) RunAndReturn(run func(...git.Option) ([]types.File, error)) *MockGit_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Tag provides a mock function with given fields: name, options
func (_m *MockGit) Tag(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Tag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Tag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tag'
type MockGit_Tag_Call struct {
	*mock.Call
}

// Tag is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockGit_Expecter) Tag(name interface{}, options ...interface{}) *MockGit_Tag_Call {
	return &MockGit_Tag_Call{Call: _e.mock.On("Tag",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockGit_Tag_Call) Run(run func(name string, options ...git.Option)) *MockGit_Tag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Tag_Call) Return(_a0 error) *MockGit_Tag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Tag_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_Tag_Call {
	_c.Call.Return(run)
	return _c
}

// UnsetConfig provides a mock function with given fields: key, options
func (_m *MockGit) UnsetConfig(key string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(key, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_UnsetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsetConfig'
type MockGit_UnsetConfig_Call struct {
	*mock.Call
}

// UnsetConfig is a helper method to define mock.On call
//   - key string
//   - options ...git.Option
func (_e *MockGit_Expecter) UnsetConfig(key interface{}, options ...interface{}) *MockGit_UnsetConfig_Call {
	return &MockGit_UnsetConfig_Call{Call: _e.mock.On("UnsetConfig",
		append([]interface{}{key}, options...)...)}
}

func (_c *MockGit_UnsetConfig_Call) Run(run func(key string, options ...git.Option)) *MockGit_UnsetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_UnsetConfig_Call) Return(_a0 error) *MockGit_UnsetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_UnsetConfig_Call) RunAndReturn(run func(string, ...git.Option) error) *MockGit_UnsetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGit creates a new instance of MockGit. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGit(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGit {
	mock := &MockGit{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
