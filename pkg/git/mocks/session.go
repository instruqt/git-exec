// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	git "github.com/instruqt/git-exec/pkg/git"
	mock "github.com/stretchr/testify/mock"

	types "github.com/instruqt/git-exec/pkg/git/types"
)

// MockSession is an autogenerated mock type for the Session type
type MockSession struct {
	mock.Mock
}

type MockSession_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSession) EXPECT() *MockSession_Expecter {
	return &MockSession_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: files, options
func (_m *MockSession) Add(files []string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, ...git.Option) error); ok {
		r0 = rf(files, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockSession_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - files []string
//   - options ...git.Option
func (_e *MockSession_Expecter) Add(files interface{}, options ...interface{}) *MockSession_Add_Call {
	return &MockSession_Add_Call{Call: _e.mock.On("Add",
		append([]interface{}{files}, options...)...)}
}

func (_c *MockSession_Add_Call) Run(run func(files []string, options ...git.Option)) *MockSession_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Add_Call) Return(_a0 error) *MockSession_Add_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Add_Call) RunAndReturn(run func([]string, ...git.Option) error) *MockSession_Add_Call {
	_c.Call.Return(run)
	return _c
}

// AddRemote provides a mock function with given fields: name, url, options
func (_m *MockSession) AddRemote(name string, url string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddRemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(name, url, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_AddRemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRemote'
type MockSession_AddRemote_Call struct {
	*mock.Call
}

// AddRemote is a helper method to define mock.On call
//   - name string
//   - url string
//   - options ...git.Option
func (_e *MockSession_Expecter) AddRemote(name interface{}, url interface{}, options ...interface{}) *MockSession_AddRemote_Call {
	return &MockSession_AddRemote_Call{Call: _e.mock.On("AddRemote",
		append([]interface{}{name, url}, options...)...)}
}

func (_c *MockSession_AddRemote_Call) Run(run func(name string, url string, options ...git.Option)) *MockSession_AddRemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_AddRemote_Call) Return(_a0 error) *MockSession_AddRemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_AddRemote_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_AddRemote_Call {
	_c.Call.Return(run)
	return _c
}

// Checkout provides a mock function with given fields: options
func (_m *MockSession) Checkout(options ...git.Option) (*types.CheckoutResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Checkout")
	}

	var r0 *types.CheckoutResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.CheckoutResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.CheckoutResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CheckoutResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Checkout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checkout'
type MockSession_Checkout_Call struct {
	*mock.Call
}

// Checkout is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Checkout(options ...interface{}) *MockSession_Checkout_Call {
	return &MockSession_Checkout_Call{Call: _e.mock.On("Checkout",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Checkout_Call) Run(run func(options ...git.Option)) *MockSession_Checkout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Checkout_Call) Return(_a0 *types.CheckoutResult, _a1 error) *MockSession_Checkout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Checkout_Call) RunAndReturn(run func(...git.Option) (*types.CheckoutResult, error)) *MockSession_Checkout_Call {
	_c.Call.Return(run)
	return _c
}

// Clone provides a mock function with given fields: url, destination, options
func (_m *MockSession) Clone(url string, destination string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, url, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Clone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(url, destination, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Clone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clone'
type MockSession_Clone_Call struct {
	*mock.Call
}

// Clone is a helper method to define mock.On call
//   - url string
//   - destination string
//   - options ...git.Option
func (_e *MockSession_Expecter) Clone(url interface{}, destination interface{}, options ...interface{}) *MockSession_Clone_Call {
	return &MockSession_Clone_Call{Call: _e.mock.On("Clone",
		append([]interface{}{url, destination}, options...)...)}
}

func (_c *MockSession_Clone_Call) Run(run func(url string, destination string, options ...git.Option)) *MockSession_Clone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Clone_Call) Return(_a0 error) *MockSession_Clone_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Clone_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_Clone_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: message, options
func (_m *MockSession) Commit(message string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, message)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(message, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockSession_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - message string
//   - options ...git.Option
func (_e *MockSession_Expecter) Commit(message interface{}, options ...interface{}) *MockSession_Commit_Call {
	return &MockSession_Commit_Call{Call: _e.mock.On("Commit",
		append([]interface{}{message}, options...)...)}
}

func (_c *MockSession_Commit_Call) Run(run func(message string, options ...git.Option)) *MockSession_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Commit_Call) Return(_a0 error) *MockSession_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Commit_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranch provides a mock function with given fields: branch, options
func (_m *MockSession) CreateBranch(branch string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(branch, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_CreateBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranch'
type MockSession_CreateBranch_Call struct {
	*mock.Call
}

// CreateBranch is a helper method to define mock.On call
//   - branch string
//   - options ...git.Option
func (_e *MockSession_Expecter) CreateBranch(branch interface{}, options ...interface{}) *MockSession_CreateBranch_Call {
	return &MockSession_CreateBranch_Call{Call: _e.mock.On("CreateBranch",
		append([]interface{}{branch}, options...)...)}
}

func (_c *MockSession_CreateBranch_Call) Run(run func(branch string, options ...git.Option)) *MockSession_CreateBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_CreateBranch_Call) Return(_a0 error) *MockSession_CreateBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_CreateBranch_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_CreateBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBranch provides a mock function with given fields: branch, options
func (_m *MockSession) DeleteBranch(branch string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(branch, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_DeleteBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBranch'
type MockSession_DeleteBranch_Call struct {
	*mock.Call
}

// DeleteBranch is a helper method to define mock.On call
//   - branch string
//   - options ...git.Option
func (_e *MockSession_Expecter) DeleteBranch(branch interface{}, options ...interface{}) *MockSession_DeleteBranch_Call {
	return &MockSession_DeleteBranch_Call{Call: _e.mock.On("DeleteBranch",
		append([]interface{}{branch}, options...)...)}
}

func (_c *MockSession_DeleteBranch_Call) Run(run func(branch string, options ...git.Option)) *MockSession_DeleteBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_DeleteBranch_Call) Return(_a0 error) *MockSession_DeleteBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_DeleteBranch_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_DeleteBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRemoteTag provides a mock function with given fields: remote, tagName, options
func (_m *MockSession) DeleteRemoteTag(remote string, tagName string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, remote, tagName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRemoteTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(remote, tagName, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_DeleteRemoteTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRemoteTag'
type MockSession_DeleteRemoteTag_Call struct {
	*mock.Call
}

// DeleteRemoteTag is a helper method to define mock.On call
//   - remote string
//   - tagName string
//   - options ...git.Option
func (_e *MockSession_Expecter) DeleteRemoteTag(remote interface{}, tagName interface{}, options ...interface{}) *MockSession_DeleteRemoteTag_Call {
	return &MockSession_DeleteRemoteTag_Call{Call: _e.mock.On("DeleteRemoteTag",
		append([]interface{}{remote, tagName}, options...)...)}
}

func (_c *MockSession_DeleteRemoteTag_Call) Run(run func(remote string, tagName string, options ...git.Option)) *MockSession_DeleteRemoteTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_DeleteRemoteTag_Call) Return(_a0 error) *MockSession_DeleteRemoteTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_DeleteRemoteTag_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_DeleteRemoteTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTag provides a mock function with given fields: name, options
func (_m *MockSession) DeleteTag(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_DeleteTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTag'
type MockSession_DeleteTag_Call struct {
	*mock.Call
}

// DeleteTag is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockSession_Expecter) DeleteTag(name interface{}, options ...interface{}) *MockSession_DeleteTag_Call {
	return &MockSession_DeleteTag_Call{Call: _e.mock.On("DeleteTag",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockSession_DeleteTag_Call) Run(run func(name string, options ...git.Option)) *MockSession_DeleteTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_DeleteTag_Call) Return(_a0 error) *MockSession_DeleteTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_DeleteTag_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_DeleteTag_Call {
	_c.Call.Return(run)
	return _c
}

// Destroy provides a mock function with no fields
func (_m *MockSession) Destroy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Destroy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Destroy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Destroy'
type MockSession_Destroy_Call struct {
	*mock.Call
}

// Destroy is a helper method to define mock.On call
func (_e *MockSession_Expecter) Destroy() *MockSession_Destroy_Call {
	return &MockSession_Destroy_Call{Call: _e.mock.On("Destroy")}
}

func (_c *MockSession_Destroy_Call) Run(run func()) *MockSession_Destroy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_Destroy_Call) Return(_a0 error) *MockSession_Destroy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Destroy_Call) RunAndReturn(run func() error) *MockSession_Destroy_Call {
	_c.Call.Return(run)
	return _c
}

// Diff provides a mock function with given fields: options
func (_m *MockSession) Diff(options ...git.Option) ([]types.Diff, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Diff")
	}

	var r0 []types.Diff
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Diff, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Diff); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Diff)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Diff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Diff'
type MockSession_Diff_Call struct {
	*mock.Call
}

// Diff is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Diff(options ...interface{}) *MockSession_Diff_Call {
	return &MockSession_Diff_Call{Call: _e.mock.On("Diff",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Diff_Call) Run(run func(options ...git.Option)) *MockSession_Diff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Diff_Call) Return(_a0 []types.Diff, _a1 error) *MockSession_Diff_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Diff_Call) RunAndReturn(run func(...git.Option) ([]types.Diff, error)) *MockSession_Diff_Call {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function with given fields: options
func (_m *MockSession) Fetch(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type MockSession_Fetch_Call struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Fetch(options ...interface{}) *MockSession_Fetch_Call {
	return &MockSession_Fetch_Call{Call: _e.mock.On("Fetch",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Fetch_Call) Run(run func(options ...git.Option)) *MockSession_Fetch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Fetch_Call) Return(_a0 []types.Remote, _a1 error) *MockSession_Fetch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Fetch_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockSession_Fetch_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: key, options
func (_m *MockSession) GetConfig(key string, options ...git.Option) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) (string, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) string); ok {
		r0 = rf(key, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type MockSession_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - key string
//   - options ...git.Option
func (_e *MockSession_Expecter) GetConfig(key interface{}, options ...interface{}) *MockSession_GetConfig_Call {
	return &MockSession_GetConfig_Call{Call: _e.mock.On("GetConfig",
		append([]interface{}{key}, options...)...)}
}

func (_c *MockSession_GetConfig_Call) Run(run func(key string, options ...git.Option)) *MockSession_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_GetConfig_Call) Return(_a0 string, _a1 error) *MockSession_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_GetConfig_Call) RunAndReturn(run func(string, ...git.Option) (string, error)) *MockSession_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionConfig provides a mock function with no fields
func (_m *MockSession) GetSessionConfig() *git.SessionConfig {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSessionConfig")
	}

	var r0 *git.SessionConfig
	if rf, ok := ret.Get(0).(func() *git.SessionConfig); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.SessionConfig)
		}
	}

	return r0
}

// MockSession_GetSessionConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionConfig'
type MockSession_GetSessionConfig_Call struct {
	*mock.Call
}

// GetSessionConfig is a helper method to define mock.On call
func (_e *MockSession_Expecter) GetSessionConfig() *MockSession_GetSessionConfig_Call {
	return &MockSession_GetSessionConfig_Call{Call: _e.mock.On("GetSessionConfig")}
}

func (_c *MockSession_GetSessionConfig_Call) Run(run func()) *MockSession_GetSessionConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_GetSessionConfig_Call) Return(_a0 *git.SessionConfig) *MockSession_GetSessionConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_GetSessionConfig_Call) RunAndReturn(run func() *git.SessionConfig) *MockSession_GetSessionConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionID provides a mock function with no fields
func (_m *MockSession) GetSessionID() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSessionID")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockSession_GetSessionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionID'
type MockSession_GetSessionID_Call struct {
	*mock.Call
}

// GetSessionID is a helper method to define mock.On call
func (_e *MockSession_Expecter) GetSessionID() *MockSession_GetSessionID_Call {
	return &MockSession_GetSessionID_Call{Call: _e.mock.On("GetSessionID")}
}

func (_c *MockSession_GetSessionID_Call) Run(run func()) *MockSession_GetSessionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_GetSessionID_Call) Return(_a0 string) *MockSession_GetSessionID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_GetSessionID_Call) RunAndReturn(run func() string) *MockSession_GetSessionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserID provides a mock function with no fields
func (_m *MockSession) GetUserID() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetUserID")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockSession_GetUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserID'
type MockSession_GetUserID_Call struct {
	*mock.Call
}

// GetUserID is a helper method to define mock.On call
func (_e *MockSession_Expecter) GetUserID() *MockSession_GetUserID_Call {
	return &MockSession_GetUserID_Call{Call: _e.mock.On("GetUserID")}
}

func (_c *MockSession_GetUserID_Call) Run(run func()) *MockSession_GetUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_GetUserID_Call) Return(_a0 string) *MockSession_GetUserID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_GetUserID_Call) RunAndReturn(run func() string) *MockSession_GetUserID_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function with given fields: path, options
func (_m *MockSession) Init(path string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, path)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(path, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type MockSession_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - path string
//   - options ...git.Option
func (_e *MockSession_Expecter) Init(path interface{}, options ...interface{}) *MockSession_Init_Call {
	return &MockSession_Init_Call{Call: _e.mock.On("Init",
		append([]interface{}{path}, options...)...)}
}

func (_c *MockSession_Init_Call) Run(run func(path string, options ...git.Option)) *MockSession_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Init_Call) Return(_a0 error) *MockSession_Init_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Init_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_Init_Call {
	_c.Call.Return(run)
	return _c
}

// InitRepository provides a mock function with no fields
func (_m *MockSession) InitRepository() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InitRepository")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_InitRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitRepository'
type MockSession_InitRepository_Call struct {
	*mock.Call
}

// InitRepository is a helper method to define mock.On call
func (_e *MockSession_Expecter) InitRepository() *MockSession_InitRepository_Call {
	return &MockSession_InitRepository_Call{Call: _e.mock.On("InitRepository")}
}

func (_c *MockSession_InitRepository_Call) Run(run func()) *MockSession_InitRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_InitRepository_Call) Return(_a0 error) *MockSession_InitRepository_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_InitRepository_Call) RunAndReturn(run func() error) *MockSession_InitRepository_Call {
	_c.Call.Return(run)
	return _c
}

// IsValid provides a mock function with no fields
func (_m *MockSession) IsValid() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsValid")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockSession_IsValid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValid'
type MockSession_IsValid_Call struct {
	*mock.Call
}

// IsValid is a helper method to define mock.On call
func (_e *MockSession_Expecter) IsValid() *MockSession_IsValid_Call {
	return &MockSession_IsValid_Call{Call: _e.mock.On("IsValid")}
}

func (_c *MockSession_IsValid_Call) Run(run func()) *MockSession_IsValid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_IsValid_Call) Return(_a0 bool) *MockSession_IsValid_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_IsValid_Call) RunAndReturn(run func() bool) *MockSession_IsValid_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranches provides a mock function with given fields: options
func (_m *MockSession) ListBranches(options ...git.Option) ([]types.Branch, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBranches")
	}

	var r0 []types.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Branch, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Branch); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_ListBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranches'
type MockSession_ListBranches_Call struct {
	*mock.Call
}

// ListBranches is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) ListBranches(options ...interface{}) *MockSession_ListBranches_Call {
	return &MockSession_ListBranches_Call{Call: _e.mock.On("ListBranches",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_ListBranches_Call) Run(run func(options ...git.Option)) *MockSession_ListBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_ListBranches_Call) Return(_a0 []types.Branch, _a1 error) *MockSession_ListBranches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_ListBranches_Call) RunAndReturn(run func(...git.Option) ([]types.Branch, error)) *MockSession_ListBranches_Call {
	_c.Call.Return(run)
	return _c
}

// ListConfig provides a mock function with given fields: options
func (_m *MockSession) ListConfig(options ...git.Option) ([]types.ConfigEntry, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfig")
	}

	var r0 []types.ConfigEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.ConfigEntry, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.ConfigEntry); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ConfigEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_ListConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListConfig'
type MockSession_ListConfig_Call struct {
	*mock.Call
}

// ListConfig is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) ListConfig(options ...interface{}) *MockSession_ListConfig_Call {
	return &MockSession_ListConfig_Call{Call: _e.mock.On("ListConfig",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_ListConfig_Call) Run(run func(options ...git.Option)) *MockSession_ListConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_ListConfig_Call) Return(_a0 []types.ConfigEntry, _a1 error) *MockSession_ListConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_ListConfig_Call) RunAndReturn(run func(...git.Option) ([]types.ConfigEntry, error)) *MockSession_ListConfig_Call {
	_c.Call.Return(run)
	return _c
}

// ListRemotes provides a mock function with given fields: options
func (_m *MockSession) ListRemotes(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRemotes")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_ListRemotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRemotes'
type MockSession_ListRemotes_Call struct {
	*mock.Call
}

// ListRemotes is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) ListRemotes(options ...interface{}) *MockSession_ListRemotes_Call {
	return &MockSession_ListRemotes_Call{Call: _e.mock.On("ListRemotes",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_ListRemotes_Call) Run(run func(options ...git.Option)) *MockSession_ListRemotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_ListRemotes_Call) Return(_a0 []types.Remote, _a1 error) *MockSession_ListRemotes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_ListRemotes_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockSession_ListRemotes_Call {
	_c.Call.Return(run)
	return _c
}

// ListTags provides a mock function with given fields: options
func (_m *MockSession) ListTags(options ...git.Option) ([]string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]string, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []string); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_ListTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTags'
type MockSession_ListTags_Call struct {
	*mock.Call
}

// ListTags is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) ListTags(options ...interface{}) *MockSession_ListTags_Call {
	return &MockSession_ListTags_Call{Call: _e.mock.On("ListTags",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_ListTags_Call) Run(run func(options ...git.Option)) *MockSession_ListTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_ListTags_Call) Return(_a0 []string, _a1 error) *MockSession_ListTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_ListTags_Call) RunAndReturn(run func(...git.Option) ([]string, error)) *MockSession_ListTags_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function with given fields: options
func (_m *MockSession) Log(options ...git.Option) ([]types.Log, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Log")
	}

	var r0 []types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Log, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Log); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type MockSession_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Log(options ...interface{}) *MockSession_Log_Call {
	return &MockSession_Log_Call{Call: _e.mock.On("Log",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Log_Call) Run(run func(options ...git.Option)) *MockSession_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Log_Call) Return(_a0 []types.Log, _a1 error) *MockSession_Log_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Log_Call) RunAndReturn(run func(...git.Option) ([]types.Log, error)) *MockSession_Log_Call {
	_c.Call.Return(run)
	return _c
}

// Merge provides a mock function with given fields: options
func (_m *MockSession) Merge(options ...git.Option) (*types.MergeResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Merge")
	}

	var r0 *types.MergeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.MergeResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.MergeResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MergeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Merge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Merge'
type MockSession_Merge_Call struct {
	*mock.Call
}

// Merge is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Merge(options ...interface{}) *MockSession_Merge_Call {
	return &MockSession_Merge_Call{Call: _e.mock.On("Merge",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Merge_Call) Run(run func(options ...git.Option)) *MockSession_Merge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Merge_Call) Return(_a0 *types.MergeResult, _a1 error) *MockSession_Merge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Merge_Call) RunAndReturn(run func(...git.Option) (*types.MergeResult, error)) *MockSession_Merge_Call {
	_c.Call.Return(run)
	return _c
}

// MergeAbort provides a mock function with no fields
func (_m *MockSession) MergeAbort() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MergeAbort")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_MergeAbort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeAbort'
type MockSession_MergeAbort_Call struct {
	*mock.Call
}

// MergeAbort is a helper method to define mock.On call
func (_e *MockSession_Expecter) MergeAbort() *MockSession_MergeAbort_Call {
	return &MockSession_MergeAbort_Call{Call: _e.mock.On("MergeAbort")}
}

func (_c *MockSession_MergeAbort_Call) Run(run func()) *MockSession_MergeAbort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_MergeAbort_Call) Return(_a0 error) *MockSession_MergeAbort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_MergeAbort_Call) RunAndReturn(run func() error) *MockSession_MergeAbort_Call {
	_c.Call.Return(run)
	return _c
}

// MergeContinue provides a mock function with no fields
func (_m *MockSession) MergeContinue() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MergeContinue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_MergeContinue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeContinue'
type MockSession_MergeContinue_Call struct {
	*mock.Call
}

// MergeContinue is a helper method to define mock.On call
func (_e *MockSession_Expecter) MergeContinue() *MockSession_MergeContinue_Call {
	return &MockSession_MergeContinue_Call{Call: _e.mock.On("MergeContinue")}
}

func (_c *MockSession_MergeContinue_Call) Run(run func()) *MockSession_MergeContinue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSession_MergeContinue_Call) Return(_a0 error) *MockSession_MergeContinue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_MergeContinue_Call) RunAndReturn(run func() error) *MockSession_MergeContinue_Call {
	_c.Call.Return(run)
	return _c
}

// Pull provides a mock function with given fields: options
func (_m *MockSession) Pull(options ...git.Option) (*types.MergeResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Pull")
	}

	var r0 *types.MergeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) (*types.MergeResult, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) *types.MergeResult); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MergeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Pull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pull'
type MockSession_Pull_Call struct {
	*mock.Call
}

// Pull is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Pull(options ...interface{}) *MockSession_Pull_Call {
	return &MockSession_Pull_Call{Call: _e.mock.On("Pull",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Pull_Call) Run(run func(options ...git.Option)) *MockSession_Pull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Pull_Call) Return(_a0 *types.MergeResult, _a1 error) *MockSession_Pull_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Pull_Call) RunAndReturn(run func(...git.Option) (*types.MergeResult, error)) *MockSession_Pull_Call {
	_c.Call.Return(run)
	return _c
}

// Push provides a mock function with given fields: options
func (_m *MockSession) Push(options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Push")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.Remote, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.Remote); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Push_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Push'
type MockSession_Push_Call struct {
	*mock.Call
}

// Push is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Push(options ...interface{}) *MockSession_Push_Call {
	return &MockSession_Push_Call{Call: _e.mock.On("Push",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Push_Call) Run(run func(options ...git.Option)) *MockSession_Push_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Push_Call) Return(_a0 []types.Remote, _a1 error) *MockSession_Push_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Push_Call) RunAndReturn(run func(...git.Option) ([]types.Remote, error)) *MockSession_Push_Call {
	_c.Call.Return(run)
	return _c
}

// PushTags provides a mock function with given fields: remote, options
func (_m *MockSession) PushTags(remote string, options ...git.Option) ([]types.Remote, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, remote)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PushTags")
	}

	var r0 []types.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) ([]types.Remote, error)); ok {
		return rf(remote, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) []types.Remote); ok {
		r0 = rf(remote, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(remote, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_PushTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PushTags'
type MockSession_PushTags_Call struct {
	*mock.Call
}

// PushTags is a helper method to define mock.On call
//   - remote string
//   - options ...git.Option
func (_e *MockSession_Expecter) PushTags(remote interface{}, options ...interface{}) *MockSession_PushTags_Call {
	return &MockSession_PushTags_Call{Call: _e.mock.On("PushTags",
		append([]interface{}{remote}, options...)...)}
}

func (_c *MockSession_PushTags_Call) Run(run func(remote string, options ...git.Option)) *MockSession_PushTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_PushTags_Call) Return(_a0 []types.Remote, _a1 error) *MockSession_PushTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_PushTags_Call) RunAndReturn(run func(string, ...git.Option) ([]types.Remote, error)) *MockSession_PushTags_Call {
	_c.Call.Return(run)
	return _c
}

// Rebase provides a mock function with given fields: options
func (_m *MockSession) Rebase(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Rebase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Rebase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rebase'
type MockSession_Rebase_Call struct {
	*mock.Call
}

// Rebase is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Rebase(options ...interface{}) *MockSession_Rebase_Call {
	return &MockSession_Rebase_Call{Call: _e.mock.On("Rebase",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Rebase_Call) Run(run func(options ...git.Option)) *MockSession_Rebase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Rebase_Call) Return(_a0 error) *MockSession_Rebase_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Rebase_Call) RunAndReturn(run func(...git.Option) error) *MockSession_Rebase_Call {
	_c.Call.Return(run)
	return _c
}

// Reflog provides a mock function with given fields: options
func (_m *MockSession) Reflog(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Reflog")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Reflog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reflog'
type MockSession_Reflog_Call struct {
	*mock.Call
}

// Reflog is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Reflog(options ...interface{}) *MockSession_Reflog_Call {
	return &MockSession_Reflog_Call{Call: _e.mock.On("Reflog",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Reflog_Call) Run(run func(options ...git.Option)) *MockSession_Reflog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Reflog_Call) Return(_a0 error) *MockSession_Reflog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Reflog_Call) RunAndReturn(run func(...git.Option) error) *MockSession_Reflog_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: options
func (_m *MockSession) Remove(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockSession_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Remove(options ...interface{}) *MockSession_Remove_Call {
	return &MockSession_Remove_Call{Call: _e.mock.On("Remove",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Remove_Call) Run(run func(options ...git.Option)) *MockSession_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Remove_Call) Return(_a0 error) *MockSession_Remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Remove_Call) RunAndReturn(run func(...git.Option) error) *MockSession_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRemote provides a mock function with given fields: name, options
func (_m *MockSession) RemoveRemote(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_RemoveRemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRemote'
type MockSession_RemoveRemote_Call struct {
	*mock.Call
}

// RemoveRemote is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockSession_Expecter) RemoveRemote(name interface{}, options ...interface{}) *MockSession_RemoveRemote_Call {
	return &MockSession_RemoveRemote_Call{Call: _e.mock.On("RemoveRemote",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockSession_RemoveRemote_Call) Run(run func(name string, options ...git.Option)) *MockSession_RemoveRemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_RemoveRemote_Call) Return(_a0 error) *MockSession_RemoveRemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_RemoveRemote_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_RemoveRemote_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: files, options
func (_m *MockSession) Reset(files []string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, ...git.Option) error); ok {
		r0 = rf(files, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type MockSession_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - files []string
//   - options ...git.Option
func (_e *MockSession_Expecter) Reset(files interface{}, options ...interface{}) *MockSession_Reset_Call {
	return &MockSession_Reset_Call{Call: _e.mock.On("Reset",
		append([]interface{}{files}, options...)...)}
}

func (_c *MockSession_Reset_Call) Run(run func(files []string, options ...git.Option)) *MockSession_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Reset_Call) Return(_a0 error) *MockSession_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Reset_Call) RunAndReturn(run func([]string, ...git.Option) error) *MockSession_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// ResolveConflicts provides a mock function with given fields: resolutions
func (_m *MockSession) ResolveConflicts(resolutions []types.ConflictResolution) error {
	ret := _m.Called(resolutions)

	if len(ret) == 0 {
		panic("no return value specified for ResolveConflicts")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]types.ConflictResolution) error); ok {
		r0 = rf(resolutions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_ResolveConflicts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveConflicts'
type MockSession_ResolveConflicts_Call struct {
	*mock.Call
}

// ResolveConflicts is a helper method to define mock.On call
//   - resolutions []types.ConflictResolution
func (_e *MockSession_Expecter) ResolveConflicts(resolutions interface{}) *MockSession_ResolveConflicts_Call {
	return &MockSession_ResolveConflicts_Call{Call: _e.mock.On("ResolveConflicts", resolutions)}
}

func (_c *MockSession_ResolveConflicts_Call) Run(run func(resolutions []types.ConflictResolution)) *MockSession_ResolveConflicts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]types.ConflictResolution))
	})
	return _c
}

func (_c *MockSession_ResolveConflicts_Call) Return(_a0 error) *MockSession_ResolveConflicts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_ResolveConflicts_Call) RunAndReturn(run func([]types.ConflictResolution) error) *MockSession_ResolveConflicts_Call {
	_c.Call.Return(run)
	return _c
}

// Revert provides a mock function with given fields: options
func (_m *MockSession) Revert(options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Revert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...git.Option) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Revert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Revert'
type MockSession_Revert_Call struct {
	*mock.Call
}

// Revert is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Revert(options ...interface{}) *MockSession_Revert_Call {
	return &MockSession_Revert_Call{Call: _e.mock.On("Revert",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Revert_Call) Run(run func(options ...git.Option)) *MockSession_Revert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Revert_Call) Return(_a0 error) *MockSession_Revert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Revert_Call) RunAndReturn(run func(...git.Option) error) *MockSession_Revert_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: key, value, options
func (_m *MockSession) SetConfig(key string, value string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(key, value, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type MockSession_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - key string
//   - value string
//   - options ...git.Option
func (_e *MockSession_Expecter) SetConfig(key interface{}, value interface{}, options ...interface{}) *MockSession_SetConfig_Call {
	return &MockSession_SetConfig_Call{Call: _e.mock.On("SetConfig",
		append([]interface{}{key, value}, options...)...)}
}

func (_c *MockSession_SetConfig_Call) Run(run func(key string, value string, options ...git.Option)) *MockSession_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_SetConfig_Call) Return(_a0 error) *MockSession_SetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_SetConfig_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetRemoteURL provides a mock function with given fields: name, url, options
func (_m *MockSession) SetRemoteURL(name string, url string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRemoteURL")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(name, url, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_SetRemoteURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRemoteURL'
type MockSession_SetRemoteURL_Call struct {
	*mock.Call
}

// SetRemoteURL is a helper method to define mock.On call
//   - name string
//   - url string
//   - options ...git.Option
func (_e *MockSession_Expecter) SetRemoteURL(name interface{}, url interface{}, options ...interface{}) *MockSession_SetRemoteURL_Call {
	return &MockSession_SetRemoteURL_Call{Call: _e.mock.On("SetRemoteURL",
		append([]interface{}{name, url}, options...)...)}
}

func (_c *MockSession_SetRemoteURL_Call) Run(run func(name string, url string, options ...git.Option)) *MockSession_SetRemoteURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_SetRemoteURL_Call) Return(_a0 error) *MockSession_SetRemoteURL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_SetRemoteURL_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_SetRemoteURL_Call {
	_c.Call.Return(run)
	return _c
}

// SetUpstream provides a mock function with given fields: branch, remote, options
func (_m *MockSession) SetUpstream(branch string, remote string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, branch, remote)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetUpstream")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...git.Option) error); ok {
		r0 = rf(branch, remote, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_SetUpstream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUpstream'
type MockSession_SetUpstream_Call struct {
	*mock.Call
}

// SetUpstream is a helper method to define mock.On call
//   - branch string
//   - remote string
//   - options ...git.Option
func (_e *MockSession_Expecter) SetUpstream(branch interface{}, remote interface{}, options ...interface{}) *MockSession_SetUpstream_Call {
	return &MockSession_SetUpstream_Call{Call: _e.mock.On("SetUpstream",
		append([]interface{}{branch, remote}, options...)...)}
}

func (_c *MockSession_SetUpstream_Call) Run(run func(branch string, remote string, options ...git.Option)) *MockSession_SetUpstream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_SetUpstream_Call) Return(_a0 error) *MockSession_SetUpstream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_SetUpstream_Call) RunAndReturn(run func(string, string, ...git.Option) error) *MockSession_SetUpstream_Call {
	_c.Call.Return(run)
	return _c
}

// SetWorkingDirectory provides a mock function with given fields: wd
func (_m *MockSession) SetWorkingDirectory(wd string) {
	_m.Called(wd)
}

// MockSession_SetWorkingDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWorkingDirectory'
type MockSession_SetWorkingDirectory_Call struct {
	*mock.Call
}

// SetWorkingDirectory is a helper method to define mock.On call
//   - wd string
func (_e *MockSession_Expecter) SetWorkingDirectory(wd interface{}) *MockSession_SetWorkingDirectory_Call {
	return &MockSession_SetWorkingDirectory_Call{Call: _e.mock.On("SetWorkingDirectory", wd)}
}

func (_c *MockSession_SetWorkingDirectory_Call) Run(run func(wd string)) *MockSession_SetWorkingDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockSession_SetWorkingDirectory_Call) Return() *MockSession_SetWorkingDirectory_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockSession_SetWorkingDirectory_Call) RunAndReturn(run func(string)) *MockSession_SetWorkingDirectory_Call {
	_c.Run(run)
	return _c
}

// Show provides a mock function with given fields: object, options
func (_m *MockSession) Show(object string, options ...git.Option) (*types.Log, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, object)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Show")
	}

	var r0 *types.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) (*types.Log, error)); ok {
		return rf(object, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...git.Option) *types.Log); ok {
		r0 = rf(object, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...git.Option) error); ok {
		r1 = rf(object, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Show_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Show'
type MockSession_Show_Call struct {
	*mock.Call
}

// Show is a helper method to define mock.On call
//   - object string
//   - options ...git.Option
func (_e *MockSession_Expecter) Show(object interface{}, options ...interface{}) *MockSession_Show_Call {
	return &MockSession_Show_Call{Call: _e.mock.On("Show",
		append([]interface{}{object}, options...)...)}
}

func (_c *MockSession_Show_Call) Run(run func(object string, options ...git.Option)) *MockSession_Show_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Show_Call) Return(_a0 *types.Log, _a1 error) *MockSession_Show_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Show_Call) RunAndReturn(run func(string, ...git.Option) (*types.Log, error)) *MockSession_Show_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: options
func (_m *MockSession) Status(options ...git.Option) ([]types.File, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 []types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(...git.Option) ([]types.File, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...git.Option) []types.File); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(...git.Option) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSession_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockSession_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - options ...git.Option
func (_e *MockSession_Expecter) Status(options ...interface{}) *MockSession_Status_Call {
	return &MockSession_Status_Call{Call: _e.mock.On("Status",
		append([]interface{}{}, options...)...)}
}

func (_c *MockSession_Status_Call) Run(run func(options ...git.Option)) *MockSession_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Status_Call) Return(_a0 []types.File, _a1 error) *MockSession_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSession_Status_Call) RunAndReturn(run func(...git.Option) ([]types.File, error)) *MockSession_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Tag provides a mock function with given fields: name, options
func (_m *MockSession) Tag(name string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Tag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_Tag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tag'
type MockSession_Tag_Call struct {
	*mock.Call
}

// Tag is a helper method to define mock.On call
//   - name string
//   - options ...git.Option
func (_e *MockSession_Expecter) Tag(name interface{}, options ...interface{}) *MockSession_Tag_Call {
	return &MockSession_Tag_Call{Call: _e.mock.On("Tag",
		append([]interface{}{name}, options...)...)}
}

func (_c *MockSession_Tag_Call) Run(run func(name string, options ...git.Option)) *MockSession_Tag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_Tag_Call) Return(_a0 error) *MockSession_Tag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_Tag_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_Tag_Call {
	_c.Call.Return(run)
	return _c
}

// UnsetConfig provides a mock function with given fields: key, options
func (_m *MockSession) UnsetConfig(key string, options ...git.Option) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...git.Option) error); ok {
		r0 = rf(key, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_UnsetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsetConfig'
type MockSession_UnsetConfig_Call struct {
	*mock.Call
}

// UnsetConfig is a helper method to define mock.On call
//   - key string
//   - options ...git.Option
func (_e *MockSession_Expecter) UnsetConfig(key interface{}, options ...interface{}) *MockSession_UnsetConfig_Call {
	return &MockSession_UnsetConfig_Call{Call: _e.mock.On("UnsetConfig",
		append([]interface{}{key}, options...)...)}
}

func (_c *MockSession_UnsetConfig_Call) Run(run func(key string, options ...git.Option)) *MockSession_UnsetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]git.Option, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(git.Option)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockSession_UnsetConfig_Call) Return(_a0 error) *MockSession_UnsetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_UnsetConfig_Call) RunAndReturn(run func(string, ...git.Option) error) *MockSession_UnsetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: name, email
func (_m *MockSession) UpdateUser(name string, email string) error {
	ret := _m.Called(name, email)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(name, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSession_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockSession_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - name string
//   - email string
func (_e *MockSession_Expecter) UpdateUser(name interface{}, email interface{}) *MockSession_UpdateUser_Call {
	return &MockSession_UpdateUser_Call{Call: _e.mock.On("UpdateUser", name, email)}
}

func (_c *MockSession_UpdateUser_Call) Run(run func(name string, email string)) *MockSession_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockSession_UpdateUser_Call) Return(_a0 error) *MockSession_UpdateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSession_UpdateUser_Call) RunAndReturn(run func(string, string) error) *MockSession_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSession creates a new instance of MockSession. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSession(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSession {
	mock := &MockSession{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
